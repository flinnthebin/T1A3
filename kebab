#!/usr/bin/python3

# kebab - remaps directories and files to use kebab-case naming convention. 
# the kebab-case format was selected as it is not commonly associated with programming languages, making it a convenient choice for organizing a linux filesystem
# the purpose of the script is to simplify and standardize navigation within the filesystem.
# feature 1 - create a backup of the original directory tree in case of user error
# feature 2 - print file information for the items that have been reorganized
# feature 3 - rename a directory tree to kebab case

# use case: standardization of repositories cloned from github to keep navigation across a system uniform.

import os
import sys
import subprocess
import shutil

def usage():
  if len(sys.argv) < 2:
    print("""lowercase - a tool to remap directories and files to kebab case.
    usage: lowercase <directory>""")
    sys.exit(1)

def create_backup(directory):
    backup_name = f"{directory}_backup.tar.gz"
    shutil.make_archive(backup_name[:-7], 'gztar', directory)
    return backup_name

def confirmation(argv1):
  maxdepth = int(input("Please enter the max depth to rename (integer): "))
  confirm = input(f"Do you want to rename the following directory tree to kebab-case? [y/n]")
  if confirm.lower() == "y":
    backup_name = create_backup(argv1)
    print(f"Backup created: {backup_name}")
    try:
      analysis_results = {}
      rename_all(argv1, dirdepth=0, maxdepth=maxdepth, analysis_results=analysis_results)
      print_analysis_report(analysis_results)
    except:
      print("Something went wrong while renaming the files.")
  else:
    print("would be a lot cooler if you did.")

def analyze_file(file_path):
    file_type = subprocess.getoutput(f"file -b --mime-type {file_path}")
    word_count = subprocess.getoutput(f"wc -w {file_path}")
    return {"file_type": file_type, "word_count": word_count.strip().split()[0]}

def print_analysis_report(analysis_results):
    print("\nAnalysis Report:")
    for file_path, result in analysis_results.items():
        print(f"\nFile: {file_path}")
        print(f"File Type: {result['file_type']}")
        print(f"Word Count: {result['word_count']}")

def rename(current_name, new_name):
  try:
    os.rename(current_name, new_name)
  except PermissionError as e:
    print("Permission Error: ", e)  

def rename_all(directory, dirdepth=0, maxdepth=5, renamed={}, analysis_results={}):
  try:
    new_name = directory.strip().lower().replace(" ", "-").replace("_", "-")
    if directory not in renamed:
      rename(directory, new_name)
      renamed[directory] = new_name
    directory = new_name
  except PermissionError as e:
    print("Permission Error: ", e)
    return

  for dirpath, dirnames, filenames in os.walk(directory):
    for dirname in dirnames:
      old_name = os.path.join(dirpath, dirname)
      new_name = os.path.join(dirpath, dirname.strip().lower().replace(" ", "-").replace("_", "-"))
      if old_name not in renamed:
        rename(old_name, new_name)
        renamed[old_name] = new_name
      if dirdepth < maxdepth:
        rename_all(new_name, dirdepth=dirdepth + 1, maxdepth=maxdepth, renamed=renamed, analysis_results=analysis_results)
    for filename in filenames:
      old_name = os.path.join(dirpath, filename)
      base, ext = os.path.splitext(filename)
      new_name = os.path.join(dirpath, base.strip().lower().replace(" ", "-").replace("_", "-") + ext)
      if old_name not in renamed:
        rename(old_name, new_name)
        renamed[old_name] = new_name
        analysis_results[new_name] = analyze_file(new_name)

if __name__ == "__main__":
    usage()
    argv1 = sys.argv[1]
    confirmation(argv1)